options {
    IGNORE_CASE = true;
    static = false;
}

PARSER_BEGIN(analizador)

import java.io.*;
import java.util.*;

public class analizador {
    private static W_CPlusPlus trans = new W_CPlusPlus("output.cpp");  // Instancia para generar código C++
    private static Environment environment = new Environment();  // Entorno para manejo de ámbitos

    // Variables y métodos para el código intermedio
    static int tempCount = 0;
    static List<String> intermediateCode = new ArrayList<String>();

    static String newTemp() {
        return "t" + tempCount++;
    }

    static void emit(String op, String arg1, String arg2, String result) {
        if (op.equals("NOT")) {
            intermediateCode.add(result + " = " + op + " " + arg1);
            trans.Write_to_CPlus(result + " = " + op + " " + arg1 + ";");
        } else if (arg2.isEmpty()) {
            intermediateCode.add(result + " = " + op + " " + arg1);
            trans.Write_to_CPlus(result + " = " + op + " " + arg1 + ";");
        } else {
            intermediateCode.add(result + " = " + arg1 + " " + op + " " + arg2);
            trans.Write_to_CPlus(result + " = " + arg1 + " " + op + " " + arg2 + ";");
        }
    }

    static void readVariable(String variableName) {
        if (!environment.isDeclared(variableName)) {
            System.out.println("Error semántico: Variable '" + variableName + "' no declarada.");
            return;
        }

        Scanner scanner = new Scanner(System.in);
        String type = environment.getSymbolType(variableName);
        System.out.print("Ingrese el valor para " + variableName + " (" + type + "): ");
        try {
            switch (type) {
                case "int":
                    int intValue = scanner.nextInt();
                    environment.updateSymbolValue(variableName, intValue);
                    trans.Write_to_CPlus(variableName + " = " + intValue + ";");
                    break;
                case "float":
                    float floatValue = scanner.nextFloat();
                    environment.updateSymbolValue(variableName, floatValue);
                    trans.Write_to_CPlus(variableName + " = " + floatValue + ";");
                    break;
                case "bool":
                    boolean boolValue = scanner.nextBoolean();
                    environment.updateSymbolValue(variableName, boolValue);
                    trans.Write_to_CPlus(variableName + " = " + boolValue + ";");
                    break;
                case "string":
                    String stringValue = scanner.nextLine();
                    environment.updateSymbolValue(variableName, stringValue);
                    trans.Write_to_CPlus(variableName + " = \"" + stringValue + "\";");
                    break;
                case "char":
                    char charValue = scanner.next().charAt(0);
                    environment.updateSymbolValue(variableName, charValue);
                    trans.Write_to_CPlus(variableName + " = '" + charValue + "';");
                    break;
                default:
                    System.out.println("Tipo no soportado.");
            }
        } catch (InputMismatchException e) {
            System.out.println("Tipo de entrada incorrecto. Por favor, intente nuevamente.");
            scanner.nextLine();  // Limpia el buffer del escáner
        }
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("Por favor, proporciona el nombre del archivo fuente como argumento.");
            return;
        }

        File codigoFuente = new File(args[0]);
        environment.pushScope();  // Iniciar un ámbito global
        try {
            analizadorTokenManager lexicManager = new analizadorTokenManager(new SimpleCharStream(new FileReader(codigoFuente)));
            analizador parser = new analizador(lexicManager);
            try {
                parser.Programa();
                System.out.println("Análisis completado.");
                trans.end_to_CPlus();  // Guardar el código C++ en un archivo

                // Ejecutar el script de ensamblado
                //String command = "cmd /c start C:/analizadorSintactico/analizador/Ensamble.bat";
                //Runtime.getRuntime().exec(command);
            } catch (ParseException ex) {
                System.out.println("Error sintáctico: " + ex.getMessage());
            }
        } catch (FileNotFoundException ex) {
            System.err.println("Archivo no encontrado: " + args[0]);
        } catch (TokenMgrError ex) {
            System.err.println("Error léxico: " + ex.getMessage());
        } catch (IOException ex) {
            System.err.println("Error al escribir el archivo de salida: " + ex.getMessage());
        } finally {
            environment.popScope();  // Cerrar el ámbito global
        }
    }

    static boolean isTypeCompatible(String declaredType, Object value) {
        if (declaredType.equals("int") && value instanceof Integer) return true;
        if (declaredType.equals("float") && value instanceof Float) return true;    
        if (declaredType.equals("bool") && value instanceof Boolean) return true;
        if (declaredType.equals("string") && value instanceof String) return true;
        if (declaredType.equals("char") && value instanceof Character) return true;
        return false;
    }

    static String getType(Object value) {
        if (value instanceof Integer) return "int";
        if (value instanceof Float) return "float";
        if (value instanceof Boolean) return "bool";
        if (value instanceof String) return "string";
        if (value instanceof Character) return "char";
        return "unknown";
    }
}

class W_CPlusPlus {
    private List<String> cppCode = new ArrayList<String>();
    private String filePath;

    public W_CPlusPlus(String filePath) {
        this.filePath = filePath;
    }

    public void Write_to_CPlus(String code) {
        cppCode.add(code);
    }

    public void end_to_CPlus() throws IOException {
        BufferedWriter writer = null;
        try {
            writer = new BufferedWriter(new FileWriter(filePath));
            for (String line : cppCode) {
                writer.write(line);
                writer.newLine();
            }
        } finally {
            if (writer != null) {
                writer.close();  // Asegurarse de cerrar el writer para evitar leaks de memoria
            }
        }
    }
}

PARSER_END(analizador)

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
}

TOKEN_MGR_DECLS : {
    public Token getNextTokenB() {
        boolean bandera = false;
        Token matchedToken = null;
        int curPos = 0;
        boolean eofReached = false;
        int invalidTokenStartLine = -1;
        int invalidTokenStartColumn = -1;

        while (!eofReached) {
            try {
                curChar = input_stream.BeginToken();
            } catch (java.io.IOException e) {
                jjmatchedKind = 0;
                jjmatchedPos = -1;
                matchedToken = jjFillToken();
                return matchedToken;
            }

            try {
                input_stream.backup(0);
                while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L) {
                    curChar = input_stream.BeginToken();
                }
            } catch (java.io.IOException e1) {
                continue;
            }
            jjmatchedKind = 0x7fffffff;
            jjmatchedPos = 0;
            curPos = jjMoveStringLiteralDfa0_0();
            
            if (jjmatchedKind != 0x7fffffff) {
                if (jjmatchedPos + 1 < curPos) {
                    input_stream.backup(curPos - jjmatchedPos - 1);
                }
                
                if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
                    matchedToken = jjFillToken();
                    return matchedToken;
                }
                
            } else {
                if (invalidTokenStartLine == -1) {
                    invalidTokenStartLine = input_stream.getEndLine();
                    invalidTokenStartColumn = input_stream.getEndColumn();
                    System.out.println("Error léxico encontrado en línea " + invalidTokenStartLine + ", columna " + invalidTokenStartColumn + " se encontró un: " + curChar);
                    System.out.println("Para corregir el error elimina el carácter inválido");
                }
            }
            try {
                input_stream.readChar();
                
            } catch (java.io.IOException e1) {
                eofReached = true;
                
            }
            
        }
        matchedToken = jjFillToken();
        matchedToken.kind = analizadorTokenManager.EOF;
        return matchedToken;
    }
   
}

TOKEN : {
    < INIT: "init" >
    | < END: "end" >
    | < INTEGER: "int" >
    | < FLOAT: "float" >
    | < BOOLEANO: "bool" >
    | < STRING: "string" >
    | < PI: "pi" >
    | < EULER: "euler" >
    | < CONSTANT: "constant" >
    | < AND: "and" >
    | < OR: "or" >
    | < NOT: "not" >
    | < PRINT: "print" >
    | < INPUT: "read" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < ELSE_IF: "elseif" >
    | < WHILE: "while" >
    | < DO: "do" >
    | < DEFINE_FUNC: "define" >
    | < GET_RETURN_FUNC: "get" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < VOID: "void" >
    | < SUMA: "+" >
    | < RESTA: "-" >
    | < MULTI: "*" >
    | < DIV: "/" >
    | < IGUAL_QUE: "=?">
    | < DIFERENTE_QUE: "!=?">
    | < MAYOR_QUE: ">?">
    | < MENOR_QUE: "<?">
    | < MAYOR_IGUAL_QUE: ">=?">
    | < MENOR_IGUAL_QUE: "<=?">
    | < ASIGNA: "=" >
    | < FIN_LINE: ";" >
    | < LLAVE_IZQ: "{" >
    | < LLAVE_DER: "}" >
    | < PAREN_IZQ: "(" >
    | < PAREN_DER: ")" >
    | < CORCH_IZQ: "[" >
    | < CORCH_DER: "]" >
    | < DOBLE_PUNTO: ":" >
    | < COMA: "," >
    | < PUNTO: "." >
    | < NOMBRE_VAR: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])* >
    | < NUMERO: (["0"-"9"])+ >
    | <DECIMAL : (["0"-"9"])+["."](["0"-"9"])+ >
    | < CADENA: "\"" (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | [" "] | [","] | ["."] | ["!"])+ "\"" >
    | < CARACTER: "'" (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | [" "] | [","] | ["."] | ["!"]) "'" >
}

void Main() : {}
{
    try {
        Programa()
        <EOF>
    } catch (ParseException e) {
        System.out.println("Error de parseo: " + e.getMessage());
    }
}

void Programa() : {}
{
    <INIT>
    Bloque()
    <END>
}

void Bloque() : {}
{
    <LLAVE_IZQ>
    Sentencias()
    <LLAVE_DER>
}

void Sentencias() : {}
{
    (   
       
        Impresion()
        | If()
        | Declaracion()
        | Inicializacion()
        | Lectura()
        | While()
        | DoWhile()
        | Funcion()

    )*
}

void Arreglo() : {}
{
    try { <CORCH_IZQ> } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró corchete izquierdo [ en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    try { <NUMERO> } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró un número en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    try { <CORCH_DER> } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró corchete derecho ] en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    (Arreglo())*
}

void Operacion() : {}
{
    (
        (<SUMA> | <RESTA> | <MULTI> | <DIV>) (<NUMERO> | <NOMBRE_VAR>| <DECIMAL>)
        | (<AND> | <OR> | <NOT>) (<NUMERO> | <NOMBRE_VAR>)
    )
}

void Lectura() : {
    Token var = null;
}

{
    <INPUT>
    var = <NOMBRE_VAR> // Captura el token para el nombre de la variable
    (<PAREN_IZQ> <PAREN_DER>)* // Opcional, maneja paréntesis que podrían seguir al nombre de la variable
    try {
        { 
            if (var != null) {
                readVariable(var.image); // Usa el nombre de la variable para leer el valor
            } else {
                throw new ParseException("Nombre de variable esperado después de 'read'.");
            }
        }
        <FIN_LINE>
    } catch (ParseException ex) {
        System.out.println("Error sintáctico: " + ex.getMessage() + " en la línea " 
            + token.beginLine + ", columna " + token.beginColumn);
    }
}

void Impresion() : {}
{
    <PRINT>
    try {
    <PAREN_IZQ>
    } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró paréntesis izquierdo ( en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    {
        String resultado = Expresion();
        System.out.println(resultado);
    }
    (
    Arreglo()
    )?
    try {
    <PAREN_DER>
     } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró paréntesis derecho ) en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    try {
    <FIN_LINE>
     } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró punto y coma ; en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
}

void Declaracion() : {
    Token tipo;
    Token var;
    Object expr = null;  // Cambiar tipo a Object para manejar correctamente los tipos
    String tipoEsperado = null;
}

{
    (
        <INTEGER> { tipoEsperado = "int"; }
        |
        <FLOAT> { tipoEsperado = "float"; }
        |
        <BOOLEANO> { tipoEsperado = "bool"; }
        |
        <STRING> { tipoEsperado = "string"; }
    )
    var = <NOMBRE_VAR>
    (
        <ASIGNA> expr = Valor()  // Usar Valor() para manejar correctamente los tipos
    )?
    <FIN_LINE>
    {
        if (environment.isDeclaredLocally(var.image)) {
            System.out.println("Error semántico: Variable '" + var.image + "' ya declarada.");
        } else {
            environment.declareSymbol(var.image, tipoEsperado);
            if (expr != null && !isTypeCompatible(tipoEsperado, expr)) {
                System.out.println("Error semántico: Tipo de dato incorrecto para la variable '" + var.image + "'. en la linea: " + var.beginLine + "'. Esperado: " + tipoEsperado + ", encontrado: " + getType(expr) + ".");
            }
            // Generar código intermedio y C++ para la declaración si hay una asignación
            if (expr != null) {
                emit("=", expr.toString(), "", var.image);  // Asegurarse de convertir expr a String para emitir
                trans.Write_to_CPlus(tipoEsperado + " " + var.image + " = " + expr.toString() + ";");
            } else {
                trans.Write_to_CPlus(tipoEsperado + " " + var.image + ";");
            }
        }
    }
}

Object Valor() : {
    Token valorToken;
    Object result = null;
}

{
    valorToken = <NUMERO>(Operacion())* { result = Integer.parseInt(valorToken.image); return result; }
    |
    valorToken = <DECIMAL> { result = Float.parseFloat(valorToken.image); return result; }
    |
    valorToken = <CADENA> { result = valorToken.image.substring(1, valorToken.image.length() - 1); return result; }
    |
    valorToken = <NOMBRE_VAR> { result = environment.getSymbolType(valorToken.image); return result; }  // Corrección para manejar variables correctamente
    |
    <TRUE> { return Boolean.TRUE; }
    |
    <FALSE> { return Boolean.FALSE; }
    |
    <PAREN_IZQ> (<NOMBRE_VAR>|<NUMERO>|<DECIMAL>)Operacion() Termino() Valor()<PAREN_DER> { return result; }
    |
    Arreglo() {return result;}
    |
    { return null; }  // Retorno explícito para cualquier caso no cubierto
}

void Inicializacion() : {
    Token var;
    String expr;
}

{
    var = <NOMBRE_VAR> <ASIGNA> expr = Expresion() <FIN_LINE>
    {
        if (!environment.isDeclared(var.image)) {
            emit("=", expr, "", var.image);
            trans.Write_to_CPlus(var.image + " = " + expr + ";");
            System.out.println("Error semántico: Variable '" + var.image + "' no declarada.");
        }
    }
}

String ExpresionLogica() : {
    String t1 = "", t2 = "", temp = "";
    Token op = null;  // Inicializar op
}

{
    t1 = Expresion()
    (
        (op = <IGUAL_QUE> | <DIFERENTE_QUE> | <MAYOR_QUE> | <MENOR_QUE> | <MAYOR_IGUAL_QUE> | <MENOR_IGUAL_QUE> | <AND> | <OR>)
        t2 = Expresion()
        {
            if (op != null && t2 != null) {
                temp = newTemp();
                emit(op.image, t1, t2, temp);
                t1 = temp;
            }
        }
    )*
    { return t1; }
}

String Expresion() : {
    String t1, t2;
    Token addop;
}

{
    t1 = Termino()
    (
        addop = <SUMA> t2 = Termino() {
            String temp = newTemp();
            emit(addop.image, t1, t2, temp);
            trans.Write_to_CPlus(temp + " = " + t1 + " + " + t2 + ";");
            t1 = temp;
        }
        | addop = <RESTA> t2 = Termino() {
            String temp = newTemp();
            emit(addop.image, t1, t2, temp);
            trans.Write_to_CPlus(temp + " = " + t1 + " - " + t2 + ";");
            t1 = temp;
        }
        // Añadir las demás operaciones aquí...
    )*
    { return t1; }
}

String Termino() : {
    String t1, t2;
    Token mulop;
}

{
    t1 = Factor()
    (
         mulop = <MULTI> t2 = Termino() {
            String temp = newTemp();
            emit(mulop.image, t1, t2, temp);
            trans.Write_to_CPlus(temp + " = " + t1 + " * " + t2 + ";");
            t1 = temp;
        }
        |  mulop = <DIV> t2 = Termino() {
            String temp = newTemp();
            emit(mulop.image, t1, t2, temp);
            trans.Write_to_CPlus(temp + " = " + t1 + " / " + t2 + ";");
            t1 = temp;
        }
    )*
    { return t1; }
}

String Factor() : {
    Token t;
    String result = null;
}

{   
     t = <NOT> result = Factor() { String temp = newTemp(); emit(t.image, result, "", temp); trans.Write_to_CPlus(temp + " = " + t.image + " " + result + ";"); return temp; }
    |t = <NOMBRE_VAR> { return t.image; }
    | t = <NUMERO> { return t.image; }
    | t = <DECIMAL> { return t.image; }
    | t = <CADENA> { return t.image; }
    | Arreglo() { return result; }
    | "(" result = Expresion() ")" { return result; }
}

void If() : {}
{
    <IF> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> Bloque()
    (
        <ELSE_IF> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> Bloque()
    )*
    (
        <ELSE> Bloque()
    )?
}

void While() : {}
{
    <WHILE> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> Bloque()
}

void DoWhile() : {}
{
    <DO> Bloque() <WHILE> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> <FIN_LINE>
}

void Funcion() : {}
{
    <DEFINE_FUNC> <VOID> <NOMBRE_VAR> <PAREN_IZQ> <PAREN_DER> Bloque()
}