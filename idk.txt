options{
    STATIC = false;
}

PARSER_BEGIN(analizador)

public class analizador {

private static File codigoFuente;
private static Environment environment = new Environment();  // Entorno para manejo de ámbitos

}

static void readVariable(String variableName) {
        if (!environment.isDeclared(variableName)) {
            System.out.println("Error semántico: Variable '" + variableName + "' no declarada.");
            return;
        }

        Scanner scanner = new Scanner(System.in);
        String type = environment.getSymbolType(variableName);
        System.out.print("Ingrese el valor para " + variableName + " (" + type + "): ");
        try {
            switch (type) {
                case "int":
                    int intValue = scanner.nextInt();
                    environment.updateSymbolValue(variableName, intValue);
                    break;
                case "float":
                    float floatValue = scanner.nextFloat();
                    environment.updateSymbolValue(variableName, floatValue);
                    break;
                case "bool":
                    boolean boolValue = scanner.nextBoolean();
                    environment.updateSymbolValue(variableName, boolValue);
                    break;
                case "string":
                    String stringValue = scanner.nextLine();
                    environment.updateSymbolValue(variableName, stringValue);
                    break;
                default:
                    System.out.println("Tipo no soportado.");
            }
        } catch (InputMismatchException e) {
            System.out.println("Tipo de entrada incorrecto. Por favor, intente nuevamente.");
            scanner.nextLine();  // Limpia el buffer del escáner
        }
    }


    public static void main(String[] args) {
        codigoFuente = new File(args[0]);
        environment.pushScope();  // Iniciar un ámbito global
        try {
            analizadorTokenManager lexicManager = new analizadorTokenManager(new SimpleCharStream(new FileReader(codigoFuente)));
            analizador parser = new analizador(lexicManager);
            try {
                parser.Programa();
                System.out.println("Análisis completado.");
            } catch (ParseException ex) {
                System.out.println("Error sintáctico: " + ex.getMessage());
            }
        } catch (FileNotFoundException ex) {
            System.err.println("Archivo no encontrado: " + args[0]);
        } catch (TokenMgrError ex) {
            System.err.println("Error léxico: " + ex.getMessage());
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
         finally {
            environment.popScope();  // Cerrar el ámbito global
        }
    }


    static boolean isTypeCompatible(String declaredType, Object value) {
        if (declaredType.equals("int") && value instanceof Integer) return true;
        if (declaredType.equals("float") && value instanceof Float) return true;    
        if (declaredType.equals("bool") && value instanceof Boolean) return true;
        if (declaredType.equals("string") && value instanceof String) return true;
        return false;
    }

    static String getType(Object value) {
        if (value instanceof Integer) return "int";
        if (value instanceof Float) return "float";
        if (value instanceof Boolean) return "bool";
        if (value instanceof String) return "string";
        return "unknown";
    }

class SymbolTable {
    private HashMap<String, String> symbols = new HashMap<String, String>();
     private HashMap<String, Object> values = new HashMap<String, Object>();  // Almacena los valores de las variables

    public void declareSymbol(String identifier, String type) {
        symbols.put(identifier, type);
    }

    public void updateValue(String identifier, Object value) {
        if (symbols.containsKey(identifier)) {
            values.put(identifier, value);
        } else {
            System.out.println("Variable '" + identifier + "' no ha sido declarada.");
        }
    }

    public Object getValue(String identifier) {
        return values.get(identifier);
    }


    public String getSymbolType(String identifier) {
        return symbols.get(identifier);
    }

    public boolean isDeclared(String identifier) {
        return symbols.containsKey(identifier);
    }
}

class Environment {
    private LinkedList<SymbolTable> scopes = new LinkedList<SymbolTable>();

    public void pushScope() {
        scopes.push(new SymbolTable());
    }

    public void popScope() {
        if (!scopes.isEmpty()) {
            scopes.pop();
        }
    }

    public void declareSymbol(String identifier, String type) {
        if (!scopes.isEmpty()) {
            scopes.peek().declareSymbol(identifier, type);
        }
    }

    public String getSymbolType(String identifier) {
        for (SymbolTable table : scopes) {
            String type = table.getSymbolType(identifier);
            if (type != null) {
                return type;
            }
        }
        return null;
    }

    public boolean isDeclared(String identifier) {
        for (SymbolTable table : scopes) {
            if (table.isDeclared(identifier)) {
                return true;
            }
        }
        return false;
    }

    public boolean isDeclaredLocally(String identifier) {
        if (!scopes.isEmpty()) {
            return scopes.peek().isDeclared(identifier);
        }
        return false;
    }

    public void updateSymbolValue(String identifier, Object value) {
        if (!scopes.isEmpty()) {
            SymbolTable currentScope = scopes.peek();
            if (currentScope.isDeclared(identifier)) {
                currentScope.updateValue(identifier, value);
            } else {
                System.out.println("Variable '" + identifier + "' no ha sido declarada en el ámbito actual.");
            }
        } else {
            System.out.println("No hay un ámbito activo en el que actualizar la variable.");
        }
    }
}

PARSER_END(analizador)

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
}

TOKEN_MGR_DECLS : {
    public Token getNextTokenB() {
        boolean bandera = false;
        Token matchedToken = null;
        int curPos = 0;
        boolean eofReached = false;
        int invalidTokenStartLine = -1;
        int invalidTokenStartColumn = -1;

        while (!eofReached) {
            try {
                curChar = input_stream.BeginToken();
            } catch (java.io.IOException e) {
                jjmatchedKind = 0;
                jjmatchedPos = -1;
                matchedToken = jjFillToken();
                return matchedToken;
            }

            try {
                input_stream.backup(0);
                while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L) {
                    curChar = input_stream.BeginToken();
                }
            } catch (java.io.IOException e1) {
                continue;
            }
            jjmatchedKind = 0x7fffffff;
            jjmatchedPos = 0;
            curPos = jjMoveStringLiteralDfa0_0();
            
            if (jjmatchedKind != 0x7fffffff) {
                if (jjmatchedPos + 1 < curPos) {
                    input_stream.backup(curPos - jjmatchedPos - 1);
                }
                
                if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
                    matchedToken = jjFillToken();
                    return matchedToken;
                }
                
            } else {
                if (invalidTokenStartLine == -1) {
                    invalidTokenStartLine = input_stream.getEndLine();
                    invalidTokenStartColumn = input_stream.getEndColumn();
                    System.out.println("Error léxico encontrado en línea " + invalidTokenStartLine + ", columna " + invalidTokenStartColumn + " se encontró un: " + curChar);
                    System.out.println("Para corregir el error elimina el carácter inválido");
                }
            }
            try {
                input_stream.readChar();
                
            } catch (java.io.IOException e1) {
                eofReached = true;
                
            }
            
        }
        matchedToken = jjFillToken();
        matchedToken.kind = analizadorTokenManager.EOF;
        return matchedToken;
    }
   
}


TOKEN : {
    < INIT: "init" >
    | < END: "end" >
    | < INTEGER: "int" >
    | < FLOAT: "float" >
    | < BOOLEANO: "bool" >
    | < STRING: "string" >
    | < PI: "pi" >
    | < EULER: "euler" >
    | < CONSTANT: "constant" >
    | < AND: "and" >
    | < OR: "or" >
    | < NOT: "not" >
    | < PRINT: "print" >
    | < INPUT: "read" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < ELSE_IF: "elseif" >
    | < WHILE: "while" >
    | < DO: "do" >
    | < DEFINE_FUNC: "define" >
    | < GET_RETURN_FUNC: "get" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < VOID: "void" >
    | < SUMA: "+" >
    | < RESTA: "-" >
    | < MULTI: "*" >
    | < DIV: "/" >
    | < IGUAL_QUE: "=?">
    | < DIFERENTE_QUE: "!=?">
    | < MAYOR_QUE: ">?">
    | < MENOR_QUE: "<?">
    | < MAYOR_IGUAL_QUE: ">=?">
    | < MENOR_IGUAL_QUE: "<=?">
    | < ASIGNA: "=" >
    | < FIN_LINE: ";" >
    | < LLAVE_IZQ: "{" >
    | < LLAVE_DER: "}" >
    | < PAREN_IZQ: "(" >
    | < PAREN_DER: ")" >
    | < CORCH_IZQ: "[" >
    | < CORCH_DER: "]" >
    | < DOBLE_PUNTO: ":" >
    | < COMA: "," >
    | < PUNTO: "." >
    | < NOMBRE_VAR: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])* >
    | < NUMERO: (["0"-"9"])+ >
    | <DECIMAL : (["0"-"9"])+["."](["0"-"9"])+ >
    | < CADENA: "\"" (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | [" "] | [","] | ["."] | ["!"])+ "\"" >
    | < CARACTER: "'" (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | [" "] | [","] | ["."] | ["!"]) "'" >
}

void Main() : {}
{
    try {
        Programa()
        <EOF>
    } catch (ParseException e) {
        System.out.println("Error de parseo: " + e.getMessage());
    }
}

void Programa() : {}
{
    <INIT>
    Bloque()
    <END>
}

void Bloque() : {}
{
    <LLAVE_IZQ>
    Sentencias()
    <LLAVE_DER>
}

void Sentencias() : {}
{
    (   
       
        Impresion()
        | If()
        | Declaracion()
        | Inicializacion()
        | Lectura()
        | While()
        | DoWhile()
        | Funcion()

    )*
}


void Arreglo() : {}
{
    try { <CORCH_IZQ> } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró corchete izquierdo [ en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    try { <NUMERO> } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró un número en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    try { <CORCH_DER> } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró corchete derecho ] en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    (Arreglo())*
}

void Operacion() : {}
{
    (
        (<SUMA> | <RESTA> | <MULTI> | <DIV>) (<NUMERO> | <NOMBRE_VAR>| <DECIMAL>)
        | (<AND> | <OR> | <NOT>) (<NUMERO> | <NOMBRE_VAR>)
    )
}

void Lectura() : {
    Token var = null;
}
{
    <INPUT>
    var = <NOMBRE_VAR> // Captura el token para el nombre de la variable
    (<PAREN_IZQ> <PAREN_DER>)* // Opcional, maneja paréntesis que podrían seguir al nombre de la variable
    try {
        { 
            if (var != null) {
                readVariable(var.image); // Usa el nombre de la variable para leer el valor
            } else {
                throw new ParseException("Nombre de variable esperado después de 'read'.");
            }
        }
        <FIN_LINE>
    } catch (ParseException ex) {
        System.out.println("Error sintáctico: " + ex.getMessage() + " en la línea " 
            + token.beginLine + ", columna " + token.beginColumn);
    }
}




void Impresion() : {}
{
    <PRINT>
    try {
    <PAREN_IZQ>
    } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró paréntesis izquierdo ( en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    {
        String resultado = Expresion();
        System.out.println(resultado);
    }
    (
    Arreglo()
    )?
    try {
    <PAREN_DER>
     } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró paréntesis derecho ) en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
    try {
    <FIN_LINE>
     } catch (ParseException ex) {
        System.out.println("Error sintáctico, no se encontró punto y coma ; en la línea " + token.beginLine + ", columna " + token.beginColumn + " después de " + token.image);
    }
}


void Declaracion() : {
    Token tipo;
    Token var;
    Object expr = null;  // Cambiar tipo a Object para manejar correctamente los tipos
    String tipoEsperado = null;
}
{
    (
        <INTEGER> { tipoEsperado = "int"; }
        |
        <FLOAT> { tipoEsperado = "float"; }
        |
        <BOOLEANO> { tipoEsperado = "bool"; }
        |
        <STRING> { tipoEsperado = "string"; }
    )
    var = <NOMBRE_VAR>
    (
        <ASIGNA> expr = Valor()  // Usar Valor() para manejar correctamente los tipos
    )?
    <FIN_LINE>
    {
        if (environment.isDeclaredLocally(var.image)) {
            System.out.println("Error semántico: Variable '" + var.image + "' ya declarada.");
        } else {
            environment.declareSymbol(var.image, tipoEsperado);
            if (expr != null && !isTypeCompatible(tipoEsperado, expr)) {
                System.out.println("Error semántico: Tipo de dato incorrecto para la variable '" + var.image + "'. en la linea: " + var.beginLine + "'. Esperado: " + tipoEsperado + ", encontrado: " + getType(expr) + ".");
            }
            
        }
    }
}

Object Valor() : {
    Token valorToken;
    Object result = null;
}
{
    valorToken = <NUMERO>(Operacion())* { result = Integer.parseInt(valorToken.image); return result; }
    |
    valorToken = <DECIMAL> { result = Float.parseFloat(valorToken.image); return result; }
    |
    valorToken = <CADENA> { result = valorToken.image.substring(1, valorToken.image.length() - 1); return result; }
    |
    valorToken = <NOMBRE_VAR> { result = environment.getSymbolType(valorToken.image); return result; }  // Corrección para manejar variables correctamente
    |
    <TRUE> { return Boolean.TRUE; }
    |
    <FALSE> { return Boolean.FALSE; }
    |
    <PAREN_IZQ> (<NOMBRE_VAR>|<NUMERO>|<DECIMAL>)Operacion() Termino() Valor()<PAREN_DER> { return result; }
    |
    Arreglo() {return result;}
    |
    { return null; }  // Retorno explícito para cualquier caso no cubierto
}

void Inicializacion() : {
    Token var;
    String expr;
}
{
    var = <NOMBRE_VAR> <ASIGNA> expr = Expresion() <FIN_LINE>
    {
        if (!environment.isDeclared(var.image)) {
            System.out.println("Error semántico: Variable '" + var.image + "' no declarada.");
        } 
    }
}


String ExpresionLogica() : {
    Token op = null;  // Inicializar op
}
{
    Expresion()
    (
        (op = <IGUAL_QUE> | <DIFERENTE_QUE> | <MAYOR_QUE> | <MENOR_QUE> | <MAYOR_IGUAL_QUE> | <MENOR_IGUAL_QUE> | <AND> | <OR>)
        Expresion()
        
    )*
}

String Expresion() : {
    Token addop;
}
{
    t1 = Termino()
    (
        addop = <SUMA> Termino()
            
        | addop = <RESTA>  Termino() 
    
        | addop = <AND> Termino()
        | addop = <OR> Termino() 
        
        | addop = <DIFERENTE_QUE> Termino() 
        
        | addop = <MAYOR_QUE>  Termino() 
        | addop = <MENOR_QUE> Termino() 
        | addop = <MAYOR_IGUAL_QUE> Termino() 
        | addop = <MENOR_IGUAL_QUE>  Termino() 
        | addop = <IGUAL_QUE>  Termino() 
    )*
   
}

String Termino() :
{
    Token mulop;
}
{
    t1 = Factor()
    (
         mulop = <MULTI> Termino() 
        
        |  mulop = <DIV> Termino() 
    )*

}

String Factor() : {
    Token t;
    String result=null;
}
{   
     t = <NOT> result = Factor() {return result; }
    |t = <NOMBRE_VAR> { return t.image; }
    | t = <NUMERO> { return t.image; }
    | t = <DECIMAL> { return t.image; }
    | t = <CADENA> { return t.image; }
    | Arreglo(){ return result; }
    | "(" result = Expresion() ")" { return result; }
}

void If() : {}
{
    <IF> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> Bloque()
    (
        <ELSE_IF> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> Bloque()
    )*
    (
        <ELSE> Bloque()
    )?
}

void While() : {}
{
    <WHILE> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> Bloque()
}

void DoWhile() : {}
{
    <DO> Bloque() <WHILE> <PAREN_IZQ> ExpresionLogica() <PAREN_DER> <FIN_LINE>
}

void Funcion() : {}
{
    <DEFINE_FUNC> <VOID> <NOMBRE_VAR> <PAREN_IZQ> <PAREN_DER> Bloque()
}